(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{440:function(t,e,v){"use strict";v.r(e);var _=v(25),a=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"_2023秋招面试-vue篇"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2023秋招面试-vue篇"}},[t._v("#")]),t._v(" 2023秋招面试—Vue篇")]),t._v(" "),v("h2",{attrs:{id:"_1-vue的基本原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue的基本原理"}},[t._v("#")]),t._v(" 1.Vue的基本原理")]),t._v(" "),v("p",[t._v("Vue通过重写data的getter和setter方法，让数据在被渲染时，把所有用到该数据的订阅者，存放到订阅者列表中去；")]),t._v(" "),v("p",[t._v("当数据被修改时，Notify方法通知所有订阅者Watcher，来达到重新渲染的目的。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://pic1.zhimg.com/v2-87feb94070a6e1fe46f474903d678888_b.jpg",alt:""}})]),t._v(" "),v("p",[t._v("举个简单的栗子🌰：")]),t._v(" "),v("blockquote",[v("p",[t._v("《西游记》中的妖怪（Watcher）时刻惦记（订阅）着唐僧（Data），想吃唐僧肉，孙悟空（Component）在听到（get搜集依赖）唐僧被抓的消息后，做出反应（set触发依赖），准备救出师傅。于是来到了妖怪（Watcher）的老巢，跟它大战几个回合后，成功救出唐僧（Data），达到重新踏上（渲染）西天取经（Vittual DOM Tree）的目的！")])]),t._v(" "),v("h2",{attrs:{id:"_2-object-defendeproperty-来进行数据劫持有什么缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-object-defendeproperty-来进行数据劫持有什么缺点"}},[t._v("#")]),t._v(" 2.Object.defendeProperty()来进行数据劫持有什么缺点？")]),t._v(" "),v("p",[t._v("Vue2中通过下标的方式修改或新增数组属性，Object.defineProperty()检测不到数据的变化，在对属性监听时，如果嵌套对象，需要深层监听，照成性能的浪费；")]),t._v(" "),v("p",[t._v("Vue3通过使用Proxy监听整个对象，Proxy最大的好处是可以监听到任何方式数据的变化，当也存在兼容性问题，因为它是ES6的语法。")]),t._v(" "),v("h2",{attrs:{id:"_3-mvvm、mvc、mvp的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-mvvm、mvc、mvp的区别"}},[t._v("#")]),t._v(" 3.MVVM、MVC、MVP的区别")]),t._v(" "),v("p",[t._v("MVVM（Model、View、ViewModel）：Model与ViewModell通过双向数据绑定, 当Model中的值发生改变的时候，就会触发更新View，View中用户操作改变的数据也会与Model同步。")]),t._v(" "),v("p",[t._v("MVC(Model、View、Controller)：比较传统的开发模式，Model层发生变化的时候会通知有关的View层更新页面，Controller中的事件触发后，通过调用Model进行修改，从而更新View页面。")]),t._v(" "),v("p",[t._v("MVP(Model、View、Presenter)：通过Presenter层来对View层和Model层进行解耦，View层的接口暴露给Presenter,在Presenter中，将Model和View的变化绑定在一起，已实现Model和View的同步更新。")]),t._v(" "),v("h2",{attrs:{id:"_4-computed-和-watch-、methods-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-computed-和-watch-、methods-的区别"}},[t._v("#")]),t._v(" 4.computed 和 watch 、methods 的区别")]),t._v(" "),v("p",[t._v("两个互补的属性，")]),t._v(" "),v("p",[t._v("computed : computed 的值会默认走缓存路径，但是不支持异步，有异步操作时，无法监听到变化；")]),t._v(" "),v("p",[t._v("watch: 不支持缓存，支持异步监听，当数据变化时，会立马触发相应的操作，监听的两个参数newValue、oldValue。")]),t._v(" "),v("p",[t._v("methods: 只要把方法用到模板上，每一次变化就会重新渲染视图，性能开销大。")]),t._v(" "),v("h2",{attrs:{id:"_5-v-if-和-v-for-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-v-if-和-v-for-的区别"}},[t._v("#")]),t._v(" 5.v-if 和 v-for 的区别")]),t._v(" "),v("p",[v("strong",[t._v("操作手段")]),t._v("：v-if动态添加或删除DOM元素；v-show则是通过设置DOM元素的display属性控制显示或隐藏。")]),t._v(" "),v("p",[v("strong",[t._v("编译条件")]),t._v("：v-if是惰性的，如果初始条件为假，那么则什么都不做；v-show无论首次条件是否为真，都会被编译，保留DOM元素。")]),t._v(" "),v("p",[v("strong",[t._v("编译阶段")]),t._v("：v-if切换有一个局部编译/卸载的过程，切换过程中会销毁或重新内部的事件监听和子程序；v-show只是简单的切换样式。")]),t._v(" "),v("p",[v("strong",[t._v("性能消耗")]),t._v("：v-if切换性能消耗大; v-show初始化渲染消耗大。")]),t._v(" "),v("h2",{attrs:{id:"_6-v-model是如何实现的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-v-model是如何实现的"}},[t._v("#")]),t._v(" 6.v-model是如何实现的？")]),t._v(" "),v("p",[t._v("v-model本质上是父子组件通信的语法糖，这个语法糖是固定的，也就是说属性必须是value,方法名必须是input，动态的绑定到表单元素value属性上，然后监听input事件。")]),t._v(" "),v("h2",{attrs:{id:"_7-v-if-和-v-for-为什么不能一起用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-v-if-和-v-for-为什么不能一起用"}},[t._v("#")]),t._v(" 7.v-if 和 v-for 为什么不能一起用？")]),t._v(" "),v("p",[t._v("这个问题官方文档已经做了解释，v-for的优先级比v-if高，如果一起使用，每次遍历都会判断一下true还是false，这样就照成了资源的浪费。")]),t._v(" "),v("h2",{attrs:{id:"_8-vue性能优化有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue性能优化有哪些"}},[t._v("#")]),t._v(" 8.Vue性能优化有哪些？")]),t._v(" "),v("p",[v("strong",[t._v("编译阶段")]),t._v("：①尽量减少data中的数据，data中的数据会增加getter和setter,也会搜集对于的Watcher;")]),t._v(" "),v("p",[t._v("​\t\t\t\t②使用异步组件、JS代码注意防抖和节流，图片使用懒加载等；")]),t._v(" "),v("p",[t._v("​\t\t\t\t③第三方模块按需导入，key保持唯一，SPA页面采用keep-alive缓存组件。")]),t._v(" "),v("p",[v("strong",[t._v("打包优化")]),t._v("：①抽离公共文件，压缩代码，使用CDN引入第三方模块")]),t._v(" "),v("p",[v("strong",[t._v("用户体验")]),t._v("：①骨架屏，服务端开启gzip压缩等。")]),t._v(" "),v("h2",{attrs:{id:"_9-对spa单页面理解-有什么优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-对spa单页面理解-有什么优缺点"}},[t._v("#")]),t._v(" 9.对SPA单页面理解，有什么优缺点？")]),t._v(" "),v("p",[t._v("SPA(single-page applications)：单页面应用程序，在初始化加载页面时，SPA不会对因为用户的操作而重新加载或跳转。")]),t._v(" "),v("p",[t._v("优点：用户体验好，对服务器压力小，早期公司官网就是使用的这种方式。")]),t._v(" "),v("p",[t._v("缺点：初次加载耗时，前进后退路由管理比较麻烦。")]),t._v(" "),v("h2",{attrs:{id:"_10-简单说下vue生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-简单说下vue生命周期"}},[t._v("#")]),t._v(" 10.简单说下Vue生命周期")]),t._v(" "),v("p",[t._v("Vue生命周期分为")]),t._v(" "),v("p",[t._v("初始化阶段 beforeCreate、created")]),t._v(" "),v("p",[t._v("挂载阶段：beforeMonnt、monted")]),t._v(" "),v("p",[t._v("更新阶段：beforeUpdate、updated")]),t._v(" "),v("p",[t._v("销毁阶段：beforeDestroy、destroyed(Vue3中修改为beforeUnmont、Unmonted)")]),t._v(" "),v("p",[t._v("跟踪组件：renderTracked")]),t._v(" "),v("p",[t._v("触达重新渲染：renderTiggered")]),t._v(" "),v("h2",{attrs:{id:"_11-组件通信的方式有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-组件通信的方式有哪些"}},[t._v("#")]),t._v(" 11.组件通信的方式有哪些？")]),t._v(" "),v("p",[t._v("①父子组件通信：父组件通过props向子组件传递数据；子组件通过$emit和父组件通信。")]),t._v(" "),v("p",[t._v("②兄弟组件通信：本质上创建一个空的Vue实例来做消息传递对象，通信组件引入该实例，通过这个实例监听和触发事件，从而实现消息的传递。")]),t._v(" "),v("p",[t._v("③任意组件通信：使用eventBus,创建一个事件中心，相当于中转站，用它来传递和触发事件。这个时候可以使用vuex，vuex的思想就是将一些公共的数据抽离出来，将它作为一个全局的变量来管理，让后其他组件可对这个公共数据进行读写操作。")]),t._v(" "),v("h2",{attrs:{id:"_12-vuex的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-vuex的原理"}},[t._v("#")]),t._v(" 12.Vuex的原理")]),t._v(" "),v("p",[t._v("使用场景：在复杂组件之家传递数据，相当于存储共享变量的概念。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://static.vue-js.com/fa207cd0-3aca-11eb-ab90-d9ae814b240d.png",alt:""}})]),t._v(" "),v("p",[t._v("实现了一个单项数据流，在全局下拥有一个存储共享变量的容器，")]),t._v(" "),v("p",[t._v("当Vue 组件触发某些事件或动作（Actions）时，Actions 将这些动作携带的数据（commit)提交到Mutations中，")]),t._v(" "),v("p",[t._v("Mutatians就去改变 State中的数据，")]),t._v(" "),v("p",[t._v("State 中的数据改变后，最后重新渲染到Vue组件上；")]),t._v(" "),v("h2",{attrs:{id:"_13-路由的hsah-和-history-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-路由的hsah-和-history-的区别"}},[t._v("#")]),t._v(" 13.路由的hsah 和 history 的区别？")]),t._v(" "),v("p",[t._v("hsah 模式：不包含在http请求内，用来指导浏览器动作，修改hash不会重新加载页面；")]),t._v(" "),v("p",[t._v("history 模式： 使用传统的路由分发模式，history API分两大类，修改历史状态和切换历史状态；")]),t._v(" "),v("p",[t._v("修改历史状态，可使用pushState()、replaceState() 两个方法来修改浏览器历史记录栈；")]),t._v(" "),v("p",[t._v("切换历史状态，可使用 forward()、back()、 go()三个方法分别控制前进、后退、跳转操作。")]),t._v(" "),v("h2",{attrs:{id:"_14-vuex-中active-和mutation-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-vuex-中active-和mutation-的区别"}},[t._v("#")]),t._v(" 14.Vuex 中Active 和Mutation 的区别？")]),t._v(" "),v("p",[t._v("Mutation 是同步的，Active则是异步，不能直接修改 State，必须经过Mutation")]),t._v(" "),v("h2",{attrs:{id:"_15-vue-3-有哪些更新"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-vue-3-有哪些更新"}},[t._v("#")]),t._v(" 15.Vue 3 有哪些更新？")]),t._v(" "),v("p",[t._v("首先是 Composition API ,强调的是逻辑组合，将Vue底层多个响应式API 组合成 setup() 的形式；")]),t._v(" "),v("p",[t._v("一个组件支持多个根元素 fargment ；")]),t._v(" "),v("p",[t._v("Teleport,")]),t._v(" "),v("p",[t._v("Suspense,")]),t._v(" "),v("p",[t._v("尺寸上利用了 tree-shaking，打包时会去除不用的功能；")]),t._v(" "),v("h2",{attrs:{id:"_16-diff-算法了解吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-diff-算法了解吗"}},[t._v("#")]),t._v(" 16.Diff 算法了解吗？")]),t._v(" "),v("p",[t._v("Diff是发生在两个虚拟Dom上的，①首先通过key值找到不需要移动的相同节点；②判断该节点的子节点，如果新的Chilren 没有子节点，而旧的有，则删除旧子节点；③相反，如果新的Chilren 有子节点，旧的没有，则给旧的添加新节点，然后继续递归子节点；")]),t._v(" "),v("h2",{attrs:{id:"_17-data-为什么是一个函数-而不是一个对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_17-data-为什么是一个函数-而不是一个对象"}},[t._v("#")]),t._v(" 17.data 为什么是一个函数，而不是一个对象？")]),t._v(" "),v("p",[t._v("在Vue官网风格指南中有提到，如果data是一个对象的话，那么当前组件的数据就会被其他不相干组件所共享，这样就不方便管理独立的组件；")]),t._v(" "),v("h2",{attrs:{id:"_18-vue-和-react-有什么异同"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-vue-和-react-有什么异同"}},[t._v("#")]),t._v(" 18.Vue 和 React 有什么异同？")]),t._v(" "),v("p",[t._v("相同点：")]),t._v(" "),v("p",[t._v("①都提倡组件化开发的思想，将多个应用才分成明确的模块，提高复用性；")]),t._v(" "),v("p",[t._v("②都有props 的概念，允许组件之间传递参数；")]),t._v(" "),v("p",[t._v("③都使用了虚拟dom来提高重绘性能；")]),t._v(" "),v("p",[t._v("不同点：")]),t._v(" "),v("p",[t._v("①模块编写方面，Vue提倡写近似于HTML的模板，只是多了一些属性；而React 提倡Jsx的写法；")]),t._v(" "),v("p",[t._v("②虚拟dom方面处理方面，Vue在组件层面使用了 Watcher, 组件内部 Vdom 做diff算法；React 则是类似于 CPU调度的逻辑，将Vdom 这棵树微观上变成了链表，利用浏览器空闲时间做 Diff算法；")]),t._v(" "),v("h2",{attrs:{id:"_19-nexttick-原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-nexttick-原理"}},[t._v("#")]),t._v(" 19.$nextTick() 原理？")]),t._v(" "),v("p",[t._v("本质上是对Event Loop 的应用，利用Promise, setTimeout 等原生方法实现Vue 内部的异步回调；")]),t._v(" "),v("h2",{attrs:{id:"_20-vuex-和-redux-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-vuex-和-redux-的区别"}},[t._v("#")]),t._v(" 20.Vuex 和 Redux 的区别")]),t._v(" "),v("p",[t._v("Vuex 借鉴了Redux的原理，将Store作为全局的数据中心，进行模块管理，并改进了Redux的Action和Reducer函数，以mutations变化函数取代Reducer，只需在mutations函数里改变State值即可。")]),t._v(" "),v("h2",{attrs:{id:"_21-vue-router-的-params-和-query-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-vue-router-的-params-和-query-的区别"}},[t._v("#")]),t._v(" 21.Vue-Router 的 Params 和 query 的区别")]),t._v(" "),v("p",[v("strong",[t._v("query：")]),t._v(" 要用"),v("strong",[t._v("path")]),t._v("引入，url 地址类似于ajax中 "),v("strong",[t._v("get")]),t._v(" 传参，浏览器地址栏"),v("strong",[t._v("显示")]),t._v("参数，刷新时 "),v("strong",[t._v("不会")]),t._v(" 丢失query 里面的数据；\n"),v("strong",[t._v("params：")]),t._v(" 要用"),v("strong",[t._v("name")]),t._v("引入，utl 地址类似于ajax "),v("strong",[t._v("post")]),t._v(" 传参，浏览器地址栏"),v("strong",[t._v("不显示")]),t._v("参数,刷新时 "),v("strong",[t._v("会")]),t._v(" 丢失query里面的数据。")])])}),[],!1,null,null,null);e.default=a.exports}}]);